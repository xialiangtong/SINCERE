<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RateLimiter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sincere</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">RateLimiter.java</span></div><h1>RateLimiter.java</h1><pre class="source lang-java linenums">import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Rate Limiter Implementation
 * 
 * Provides both Fixed Window and Token Bucket rate limiting strategies.
 */
public class RateLimiter {

    /**
     * Decision result from a rate limit check.
     */
    public static class Decision {
        private final boolean allowed;
        private final long retryAfterMs;
        private final int remaining;

<span class="nc" id="L19">        private Decision(boolean allowed, long retryAfterMs, int remaining) {</span>
<span class="nc" id="L20">            this.allowed = allowed;</span>
<span class="nc" id="L21">            this.retryAfterMs = retryAfterMs;</span>
<span class="nc" id="L22">            this.remaining = remaining;</span>
<span class="nc" id="L23">        }</span>

        public static Decision allow(int remaining) {
<span class="nc" id="L26">            return new Decision(true, 0, remaining);</span>
        }

        public static Decision reject(long retryAfterMs) {
<span class="nc" id="L30">            return new Decision(false, retryAfterMs, 0);</span>
        }

        public boolean isAllowed() {
<span class="nc" id="L34">            return allowed;</span>
        }

        public long getRetryAfterMs() {
<span class="nc" id="L38">            return retryAfterMs;</span>
        }

        public int getRemaining() {
<span class="nc" id="L42">            return remaining;</span>
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L47" title="All 2 branches missed.">            if (allowed) {</span>
<span class="nc" id="L48">                return &quot;Decision{allowed=true, remaining=&quot; + remaining + &quot;}&quot;;</span>
            } else {
<span class="nc" id="L50">                return &quot;Decision{allowed=false, retryAfterMs=&quot; + retryAfterMs + &quot;}&quot;;</span>
            }
        }
    }

    /**
     * Rate limiting strategy interface.
     */
    public interface Strategy {
        Decision allow(String key);
        Decision tryAcquire(String key, int permits);
    }

    /**
     * Fixed Window Rate Limiter Strategy.
     * Counts requests in discrete time windows.
     */
    public static class FixedWindowStrategy implements Strategy {
        private final int maxRequests;
        private final long windowSizeMs;
<span class="nc" id="L70">        private final Map&lt;String, WindowState&gt; states = new ConcurrentHashMap&lt;&gt;();</span>

        private static class WindowState {
            long windowStart;
            int count;

<span class="nc" id="L76">            WindowState(long windowStart) {</span>
<span class="nc" id="L77">                this.windowStart = windowStart;</span>
<span class="nc" id="L78">                this.count = 0;</span>
<span class="nc" id="L79">            }</span>
        }

<span class="nc" id="L82">        public FixedWindowStrategy(int maxRequests, long windowSizeMs) {</span>
<span class="nc" id="L83">            this.maxRequests = maxRequests;</span>
<span class="nc" id="L84">            this.windowSizeMs = windowSizeMs;</span>
<span class="nc" id="L85">        }</span>

        @Override
        public Decision allow(String key) {
<span class="nc" id="L89">            return tryAcquire(key, 1);</span>
        }

        @Override
        public synchronized Decision tryAcquire(String key, int permits) {
<span class="nc" id="L94">            long now = System.currentTimeMillis();</span>
            
<span class="nc" id="L96">            WindowState state = states.computeIfAbsent(key, k -&gt; new WindowState(now));</span>

            // Check if we need to reset the window
<span class="nc bnc" id="L99" title="All 2 branches missed.">            if (now &gt;= state.windowStart + windowSizeMs) {</span>
<span class="nc" id="L100">                state.windowStart = (now / windowSizeMs) * windowSizeMs;</span>
<span class="nc" id="L101">                state.count = 0;</span>
            }

            // Check if request is allowed
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (state.count + permits &lt;= maxRequests) {</span>
<span class="nc" id="L106">                state.count += permits;</span>
<span class="nc" id="L107">                return Decision.allow(maxRequests - state.count);</span>
            } else {
<span class="nc" id="L109">                long retryAfter = (state.windowStart + windowSizeMs) - now;</span>
<span class="nc" id="L110">                return Decision.reject(retryAfter);</span>
            }
        }
    }

    /**
     * Token Bucket Rate Limiter Strategy.
     * Tokens accumulate over time up to a capacity.
     */
    public static class TokenBucketStrategy implements Strategy {
        private final int capacity;
        private final double refillRatePerMs;
<span class="nc" id="L122">        private final Map&lt;String, BucketState&gt; states = new ConcurrentHashMap&lt;&gt;();</span>

        private static class BucketState {
            double tokens;
            long lastRefillMs;

<span class="nc" id="L128">            BucketState(double tokens, long lastRefillMs) {</span>
<span class="nc" id="L129">                this.tokens = tokens;</span>
<span class="nc" id="L130">                this.lastRefillMs = lastRefillMs;</span>
<span class="nc" id="L131">            }</span>
        }

        /**
         * Creates a Token Bucket strategy.
         * @param capacity Maximum tokens in the bucket
         * @param refillTokens Number of tokens to refill
         * @param refillPeriodMs Time period for refill in milliseconds
         */
<span class="nc" id="L140">        public TokenBucketStrategy(int capacity, int refillTokens, long refillPeriodMs) {</span>
<span class="nc" id="L141">            this.capacity = capacity;</span>
<span class="nc" id="L142">            this.refillRatePerMs = (double) refillTokens / refillPeriodMs;</span>
<span class="nc" id="L143">        }</span>

        @Override
        public Decision allow(String key) {
<span class="nc" id="L147">            return tryAcquire(key, 1);</span>
        }

        @Override
        public synchronized Decision tryAcquire(String key, int permits) {
<span class="nc" id="L152">            long now = System.currentTimeMillis();</span>
            
<span class="nc" id="L154">            BucketState state = states.computeIfAbsent(key, </span>
<span class="nc" id="L155">                k -&gt; new BucketState(capacity, now));</span>

            // Refill tokens based on elapsed time
<span class="nc" id="L158">            long elapsed = now - state.lastRefillMs;</span>
<span class="nc" id="L159">            state.tokens = Math.min(capacity, state.tokens + elapsed * refillRatePerMs);</span>
<span class="nc" id="L160">            state.lastRefillMs = now;</span>

            // Check if request is allowed
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (state.tokens &gt;= permits) {</span>
<span class="nc" id="L164">                state.tokens -= permits;</span>
<span class="nc" id="L165">                return Decision.allow((int) state.tokens);</span>
            } else {
<span class="nc" id="L167">                double needed = permits - state.tokens;</span>
<span class="nc" id="L168">                long retryAfter = (long) Math.ceil(needed / refillRatePerMs);</span>
<span class="nc" id="L169">                return Decision.reject(retryAfter);</span>
            }
        }
    }

    // Instance fields
    private final Strategy strategy;

<span class="nc" id="L177">    public RateLimiter(Strategy strategy) {</span>
<span class="nc" id="L178">        this.strategy = strategy;</span>
<span class="nc" id="L179">    }</span>

    /**
     * Check if a request is allowed for the given key.
     */
    public Decision allow(String key) {
<span class="nc" id="L185">        return strategy.allow(key);</span>
    }

    /**
     * Try to acquire a number of permits for the given key.
     */
    public Decision tryAcquire(String key, int permits) {
<span class="nc" id="L192">        return strategy.tryAcquire(key, permits);</span>
    }

    // Factory methods for convenience
    public static RateLimiter fixedWindow(int maxRequests, long windowSizeMs) {
<span class="nc" id="L197">        return new RateLimiter(new FixedWindowStrategy(maxRequests, windowSizeMs));</span>
    }

    public static RateLimiter tokenBucket(int capacity, int refillTokens, long refillPeriodMs) {
<span class="nc" id="L201">        return new RateLimiter(new TokenBucketStrategy(capacity, refillTokens, refillPeriodMs));</span>
    }

    public static void main(String[] args) throws InterruptedException {
<span class="nc" id="L205">        System.out.println(&quot;=== Fixed Window Rate Limiter Demo ===&quot;);</span>
        // 5 requests per 2 seconds
<span class="nc" id="L207">        RateLimiter fixedLimiter = RateLimiter.fixedWindow(5, 2000);</span>

<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (int i = 1; i &lt;= 7; i++) {</span>
<span class="nc" id="L210">            Decision decision = fixedLimiter.allow(&quot;user1&quot;);</span>
<span class="nc" id="L211">            System.out.println(&quot;Request &quot; + i + &quot;: &quot; + decision);</span>
        }

<span class="nc" id="L214">        System.out.println(&quot;\n=== Token Bucket Rate Limiter Demo ===&quot;);</span>
        // Capacity 5, refill 5 tokens per 2 seconds
<span class="nc" id="L216">        RateLimiter tokenLimiter = RateLimiter.tokenBucket(5, 5, 2000);</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">        for (int i = 1; i &lt;= 7; i++) {</span>
<span class="nc" id="L219">            Decision decision = tokenLimiter.allow(&quot;user2&quot;);</span>
<span class="nc" id="L220">            System.out.println(&quot;Request &quot; + i + &quot;: &quot; + decision);</span>
        }

<span class="nc" id="L223">        System.out.println(&quot;\nWaiting 1 second for token refill...&quot;);</span>
<span class="nc" id="L224">        Thread.sleep(1000);</span>

<span class="nc" id="L226">        Decision afterWait = tokenLimiter.allow(&quot;user2&quot;);</span>
<span class="nc" id="L227">        System.out.println(&quot;After 1s wait: &quot; + afterWait);</span>
<span class="nc" id="L228">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>