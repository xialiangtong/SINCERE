<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProductShipping.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sincere</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">ProductShipping.java</span></div><h1>ProductShipping.java</h1><pre class="source lang-java linenums">import java.util.*;

/**
 * Product Shipping System - Undirected Graph Solution
 * 
 * Finds which products must be shipped together based on dependency rules.
 * Uses BFS to find connected components in an undirected graph.
 */
<span class="nc" id="L9">public class ProductShipping {</span>

    // ==================== Domain Classes ====================

    /**
     * Represents a product in the catalog.
     */
    public static class Product {
        private final String id;
        private final String name;

<span class="nc" id="L20">        public Product(String id, String name) {</span>
<span class="nc" id="L21">            this.id = id;</span>
<span class="nc" id="L22">            this.name = name;</span>
<span class="nc" id="L23">        }</span>

<span class="nc" id="L25">        public String getId() { return id; }</span>
<span class="nc" id="L26">        public String getName() { return name; }</span>

        @Override
        public String toString() {
<span class="nc" id="L30">            return String.format(&quot;Product{id='%s', name='%s'}&quot;, id, name);</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="nc bnc" id="L35" title="All 2 branches missed.">            if (this == o) return true;</span>
<span class="nc bnc" id="L36" title="All 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="nc" id="L37">            Product product = (Product) o;</span>
<span class="nc" id="L38">            return Objects.equals(id, product.id);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L43">            return Objects.hash(id);</span>
        }
    }

    /**
     * Represents a dependency rule between two products.
     * In an undirected graph, (A, B) means A and B must ship together.
     */
    public static class DependencyRule {
        private final String productA;
        private final String productB;

<span class="nc" id="L55">        public DependencyRule(String productA, String productB) {</span>
<span class="nc" id="L56">            this.productA = productA;</span>
<span class="nc" id="L57">            this.productB = productB;</span>
<span class="nc" id="L58">        }</span>

<span class="nc" id="L60">        public String getProductA() { return productA; }</span>
<span class="nc" id="L61">        public String getProductB() { return productB; }</span>

        @Override
        public String toString() {
<span class="nc" id="L65">            return String.format(&quot;(%s &lt;-&gt; %s)&quot;, productA, productB);</span>
        }
    }

    // ==================== Graph ====================

    /**
     * Undirected graph using adjacency list representation.
     */
    public static class UndirectedGraph {
        private final Map&lt;String, Set&lt;String&gt;&gt; adjacencyList;

<span class="nc" id="L77">        public UndirectedGraph() {</span>
<span class="nc" id="L78">            this.adjacencyList = new HashMap&lt;&gt;();</span>
<span class="nc" id="L79">        }</span>

        /**
         * Add a node to the graph.
         */
        public void addNode(String productId) {
<span class="nc" id="L85">            adjacencyList.putIfAbsent(productId, new HashSet&lt;&gt;());</span>
<span class="nc" id="L86">        }</span>

        /**
         * Add an undirected edge between two products.
         * This adds both A-&gt;B and B-&gt;A connections.
         */
        public void addEdge(String productA, String productB) {
<span class="nc" id="L93">            addNode(productA);</span>
<span class="nc" id="L94">            addNode(productB);</span>
<span class="nc" id="L95">            adjacencyList.get(productA).add(productB);</span>
<span class="nc" id="L96">            adjacencyList.get(productB).add(productA);</span>
<span class="nc" id="L97">        }</span>

        /**
         * Get all neighbors of a node.
         */
        public Set&lt;String&gt; getNeighbors(String node) {
<span class="nc" id="L103">            return adjacencyList.getOrDefault(node, Collections.emptySet());</span>
        }

        /**
         * Get all nodes in the graph.
         */
        public Set&lt;String&gt; getNodes() {
<span class="nc" id="L110">            return adjacencyList.keySet();</span>
        }

        /**
         * Check if a node exists in the graph.
         */
        public boolean hasNode(String node) {
<span class="nc" id="L117">            return adjacencyList.containsKey(node);</span>
        }
    }

    // ==================== Shipping Group ====================

    /**
     * Represents a group of products that must be shipped together.
     */
    public static class ShippingGroup {
        private final int groupId;
        private final Set&lt;String&gt; products;

<span class="nc" id="L130">        public ShippingGroup(int groupId, Set&lt;String&gt; products) {</span>
<span class="nc" id="L131">            this.groupId = groupId;</span>
<span class="nc" id="L132">            this.products = new HashSet&lt;&gt;(products);</span>
<span class="nc" id="L133">        }</span>

<span class="nc" id="L135">        public int getGroupId() { return groupId; }</span>
<span class="nc" id="L136">        public Set&lt;String&gt; getProducts() { return Collections.unmodifiableSet(products); }</span>
<span class="nc" id="L137">        public int size() { return products.size(); }</span>
<span class="nc" id="L138">        public boolean contains(String productId) { return products.contains(productId); }</span>

        @Override
        public String toString() {
<span class="nc" id="L142">            return String.format(&quot;Shipment #%d: %s&quot;, groupId, products);</span>
        }
    }

    // ==================== Shipping Result ====================

    /**
     * Result of shipping analysis containing all groups and statistics.
     */
    public static class ShippingResult {
        private final List&lt;ShippingGroup&gt; groups;
        private final int minShipments;

<span class="nc" id="L155">        public ShippingResult(List&lt;ShippingGroup&gt; groups) {</span>
<span class="nc" id="L156">            this.groups = new ArrayList&lt;&gt;(groups);</span>
<span class="nc" id="L157">            this.minShipments = groups.size();</span>
<span class="nc" id="L158">        }</span>

        public List&lt;ShippingGroup&gt; getGroups() { 
<span class="nc" id="L161">            return Collections.unmodifiableList(groups); </span>
        }
        
        public int getMinShipments() { 
<span class="nc" id="L165">            return minShipments; </span>
        }

        /**
         * Find which group contains a specific product.
         */
        public Optional&lt;ShippingGroup&gt; findGroupForProduct(String productId) {
<span class="nc" id="L172">            return groups.stream()</span>
<span class="nc" id="L173">                    .filter(g -&gt; g.contains(productId))</span>
<span class="nc" id="L174">                    .findFirst();</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L179">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L180">            sb.append(&quot;=== Shipping Analysis ===\n&quot;);</span>
<span class="nc" id="L181">            sb.append(String.format(&quot;Minimum shipments needed: %d\n&quot;, minShipments));</span>
<span class="nc" id="L182">            sb.append(&quot;\nShipping Groups:\n&quot;);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            for (ShippingGroup group : groups) {</span>
<span class="nc" id="L184">                sb.append(&quot;  &quot;).append(group).append(&quot;\n&quot;);</span>
<span class="nc" id="L185">            }</span>
<span class="nc" id="L186">            return sb.toString();</span>
        }
    }

    // ==================== Shipping Group Finder ====================

    /**
     * Finds connected components (shipping groups) using BFS.
     */
    public static class ShippingGroupFinder {
        private final UndirectedGraph graph;
        private final Set&lt;String&gt; visited;

<span class="nc" id="L199">        public ShippingGroupFinder(UndirectedGraph graph) {</span>
<span class="nc" id="L200">            this.graph = graph;</span>
<span class="nc" id="L201">            this.visited = new HashSet&lt;&gt;();</span>
<span class="nc" id="L202">        }</span>

        /**
         * Find all shipping groups (connected components).
         */
        public List&lt;ShippingGroup&gt; findGroups() {
<span class="nc" id="L208">            List&lt;ShippingGroup&gt; groups = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L209">            visited.clear();</span>
<span class="nc" id="L210">            int groupId = 1;</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">            for (String node : graph.getNodes()) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                if (!visited.contains(node)) {</span>
<span class="nc" id="L214">                    Set&lt;String&gt; component = bfs(node);</span>
<span class="nc" id="L215">                    groups.add(new ShippingGroup(groupId++, component));</span>
                }
<span class="nc" id="L217">            }</span>

<span class="nc" id="L219">            return groups;</span>
        }

        /**
         * BFS to find all nodes connected to the start node.
         */
        private Set&lt;String&gt; bfs(String startNode) {
<span class="nc" id="L226">            Set&lt;String&gt; component = new HashSet&lt;&gt;();</span>
<span class="nc" id="L227">            Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span>

<span class="nc" id="L229">            queue.offer(startNode);</span>
<span class="nc" id="L230">            visited.add(startNode);</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">            while (!queue.isEmpty()) {</span>
<span class="nc" id="L233">                String current = queue.poll();</span>
<span class="nc" id="L234">                component.add(current);</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">                for (String neighbor : graph.getNeighbors(current)) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                    if (!visited.contains(neighbor)) {</span>
<span class="nc" id="L238">                        visited.add(neighbor);</span>
<span class="nc" id="L239">                        queue.offer(neighbor);</span>
                    }
<span class="nc" id="L241">                }</span>
<span class="nc" id="L242">            }</span>

<span class="nc" id="L244">            return component;</span>
        }

        /**
         * Get the minimum number of shipments needed.
         */
        public int getMinShipments() {
<span class="nc" id="L251">            return findGroups().size();</span>
        }
    }

    // ==================== Main API ====================

    /**
     * Analyze shipping requirements for a list of products with dependency rules.
     * 
     * @param productIds List of product IDs to ship
     * @param rules List of dependency rules (A, B means A and B must ship together)
     * @return ShippingResult containing groups and minimum shipments
     */
    public static ShippingResult analyze(List&lt;String&gt; productIds, List&lt;DependencyRule&gt; rules) {
        // Build the undirected graph
<span class="nc" id="L266">        UndirectedGraph graph = new UndirectedGraph();</span>

        // Add all products as nodes
<span class="nc bnc" id="L269" title="All 2 branches missed.">        for (String productId : productIds) {</span>
<span class="nc" id="L270">            graph.addNode(productId);</span>
<span class="nc" id="L271">        }</span>

        // Add dependency edges (undirected)
<span class="nc bnc" id="L274" title="All 2 branches missed.">        for (DependencyRule rule : rules) {</span>
            // Only add edge if both products are in our list
<span class="nc bnc" id="L276" title="All 4 branches missed.">            if (graph.hasNode(rule.getProductA()) &amp;&amp; graph.hasNode(rule.getProductB())) {</span>
<span class="nc" id="L277">                graph.addEdge(rule.getProductA(), rule.getProductB());</span>
            }
<span class="nc" id="L279">        }</span>

        // Find shipping groups
<span class="nc" id="L282">        ShippingGroupFinder finder = new ShippingGroupFinder(graph);</span>
<span class="nc" id="L283">        List&lt;ShippingGroup&gt; groups = finder.findGroups();</span>

<span class="nc" id="L285">        return new ShippingResult(groups);</span>
    }

    /**
     * Convenience method using string arrays.
     */
    public static ShippingResult analyze(String[] productIds, String[][] rules) {
<span class="nc" id="L292">        List&lt;String&gt; products = Arrays.asList(productIds);</span>
<span class="nc" id="L293">        List&lt;DependencyRule&gt; dependencyRules = new ArrayList&lt;&gt;();</span>
        
<span class="nc bnc" id="L295" title="All 2 branches missed.">        for (String[] rule : rules) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">            if (rule.length &gt;= 2) {</span>
<span class="nc" id="L297">                dependencyRules.add(new DependencyRule(rule[0], rule[1]));</span>
            }
        }
        
<span class="nc" id="L301">        return analyze(products, dependencyRules);</span>
    }

    // ==================== Demo ====================

    public static void main(String[] args) {
<span class="nc" id="L307">        System.out.println(&quot;╔════════════════════════════════════════════════════════╗&quot;);</span>
<span class="nc" id="L308">        System.out.println(&quot;║       Product Shipping - Undirected Graph Demo         ║&quot;);</span>
<span class="nc" id="L309">        System.out.println(&quot;╚════════════════════════════════════════════════════════╝\n&quot;);</span>

        // Example 1: Basic connected components
<span class="nc" id="L312">        System.out.println(&quot;Example 1: Basic Grouping&quot;);</span>
<span class="nc" id="L313">        System.out.println(&quot;─────────────────────────────────────────&quot;);</span>
<span class="nc" id="L314">        String[] products1 = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;};</span>
<span class="nc" id="L315">        String[][] rules1 = {</span>
            {&quot;A&quot;, &quot;B&quot;},  // A and B must ship together
            {&quot;B&quot;, &quot;C&quot;},  // B and C must ship together
            {&quot;D&quot;, &quot;E&quot;}   // D and E must ship together
        };
        
<span class="nc" id="L321">        System.out.println(&quot;Products: &quot; + Arrays.toString(products1));</span>
<span class="nc" id="L322">        System.out.println(&quot;Rules: A&lt;-&gt;B, B&lt;-&gt;C, D&lt;-&gt;E&quot;);</span>
<span class="nc" id="L323">        System.out.println(&quot;\nGraph visualization:&quot;);</span>
<span class="nc" id="L324">        System.out.println(&quot;  A ─── B ─── C       D ─── E       F (isolated)\n&quot;);</span>
        
<span class="nc" id="L326">        ShippingResult result1 = analyze(products1, rules1);</span>
<span class="nc" id="L327">        System.out.println(result1);</span>

        // Example 2: Chain of dependencies
<span class="nc" id="L330">        System.out.println(&quot;\nExample 2: Chain Dependencies&quot;);</span>
<span class="nc" id="L331">        System.out.println(&quot;─────────────────────────────────────────&quot;);</span>
<span class="nc" id="L332">        String[] products2 = {&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;, &quot;P4&quot;, &quot;P5&quot;};</span>
<span class="nc" id="L333">        String[][] rules2 = {</span>
            {&quot;P1&quot;, &quot;P2&quot;},
            {&quot;P2&quot;, &quot;P3&quot;},
            {&quot;P3&quot;, &quot;P4&quot;},
            {&quot;P4&quot;, &quot;P5&quot;}
        };
        
<span class="nc" id="L340">        System.out.println(&quot;Products: &quot; + Arrays.toString(products2));</span>
<span class="nc" id="L341">        System.out.println(&quot;Rules: P1&lt;-&gt;P2&lt;-&gt;P3&lt;-&gt;P4&lt;-&gt;P5 (chain)\n&quot;);</span>
<span class="nc" id="L342">        System.out.println(&quot;Graph visualization:&quot;);</span>
<span class="nc" id="L343">        System.out.println(&quot;  P1 ─── P2 ─── P3 ─── P4 ─── P5\n&quot;);</span>
        
<span class="nc" id="L345">        ShippingResult result2 = analyze(products2, rules2);</span>
<span class="nc" id="L346">        System.out.println(result2);</span>

        // Example 3: Multiple isolated groups
<span class="nc" id="L349">        System.out.println(&quot;\nExample 3: Multiple Isolated Groups&quot;);</span>
<span class="nc" id="L350">        System.out.println(&quot;─────────────────────────────────────────&quot;);</span>
<span class="nc" id="L351">        String[] products3 = {&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;W&quot;};</span>
<span class="nc" id="L352">        String[][] rules3 = {}; // No dependencies</span>
        
<span class="nc" id="L354">        System.out.println(&quot;Products: &quot; + Arrays.toString(products3));</span>
<span class="nc" id="L355">        System.out.println(&quot;Rules: None (all isolated)\n&quot;);</span>
        
<span class="nc" id="L357">        ShippingResult result3 = analyze(products3, rules3);</span>
<span class="nc" id="L358">        System.out.println(result3);</span>

        // Example 4: All connected
<span class="nc" id="L361">        System.out.println(&quot;\nExample 4: All Connected (One Shipment)&quot;);</span>
<span class="nc" id="L362">        System.out.println(&quot;─────────────────────────────────────────&quot;);</span>
<span class="nc" id="L363">        String[] products4 = {&quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;};</span>
<span class="nc" id="L364">        String[][] rules4 = {</span>
            {&quot;M&quot;, &quot;N&quot;},
            {&quot;N&quot;, &quot;O&quot;},
            {&quot;O&quot;, &quot;P&quot;},
            {&quot;P&quot;, &quot;M&quot;}  // Forms a cycle - all connected
        };
        
<span class="nc" id="L371">        System.out.println(&quot;Products: &quot; + Arrays.toString(products4));</span>
<span class="nc" id="L372">        System.out.println(&quot;Rules: M&lt;-&gt;N&lt;-&gt;O&lt;-&gt;P&lt;-&gt;M (cycle - all connected)\n&quot;);</span>
<span class="nc" id="L373">        System.out.println(&quot;Graph visualization:&quot;);</span>
<span class="nc" id="L374">        System.out.println(&quot;  M ─── N&quot;);</span>
<span class="nc" id="L375">        System.out.println(&quot;  │     │&quot;);</span>
<span class="nc" id="L376">        System.out.println(&quot;  P ─── O\n&quot;);</span>
        
<span class="nc" id="L378">        ShippingResult result4 = analyze(products4, rules4);</span>
<span class="nc" id="L379">        System.out.println(result4);</span>

        // Example 5: Find which group a product belongs to
<span class="nc" id="L382">        System.out.println(&quot;\nExample 5: Query Product Group&quot;);</span>
<span class="nc" id="L383">        System.out.println(&quot;─────────────────────────────────────────&quot;);</span>
<span class="nc" id="L384">        String queryProduct = &quot;B&quot;;</span>
<span class="nc" id="L385">        result1.findGroupForProduct(queryProduct).ifPresentOrElse(</span>
<span class="nc" id="L386">            group -&gt; System.out.printf(&quot;Product '%s' belongs to %s%n&quot;, queryProduct, group),</span>
<span class="nc" id="L387">            () -&gt; System.out.printf(&quot;Product '%s' not found in any group%n&quot;, queryProduct)</span>
        );
<span class="nc" id="L389">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>